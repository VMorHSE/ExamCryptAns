\section{Режимы использования блочных шифров.}

Блочные шифры зашифровывают представленную информацию блоками фиксированной длины. Однако, если применять такие шифры непосредственно (что соответствует первому режиму далее), т.е. независимо шифровать каждый отдельный блок, шифр будет в какой-то степени уязвим к атаке “со словарём”, т.к. блоки фиксированной длины могут повторяться в открытом тексте, и, набрав достаточное количество открытых и зашифрованных текстов, злоумышленник простым сопоставлением сможет раскрывать некоторые блоки. Чтобы такого не происходило, вводятся более сложные способы (режимы) использования блочных шифров.

Согласно ГОСТ Р 34.13-2015 “Режимы работы блочных шифров”, существуют следующие режимы:

\begin{enumerate}
	\item Режим простой замены (Electronic Codebook, ЕСВ)
	\item Режим гаммирования (Counter, CTR)
	\item Режим гаммирования с обратной связью по выходу (Output Feedback, OFB)
	\item Режим простой замены с зацеплением (Cipher Block Chaining, СВС)
	\item Режим гаммирования с обратной связью по шифртексту (Cipher Feedback, CFB)
	\item Режим выработки имитовставки (Message Authentication Code algorithm)
\end{enumerate}

Для шифрования, очевидно, используются только первые 5 из них. Последний предназначен для выработки имитовставки (см. вопрос 17). При этом первый не рекомендуется к использованию по причинам, описанным в начале данного вопроса.

Если открытый текст по длине не кратен длине блока (или другому размеру, необходимому для работы соответствующего режима), он дополняется по одному из трёх алгоритмов, приведённых в том же ГОСТе.

Во всех режимах, кроме первого, используется синхропосылка IV (initialization vector, я полагаю) – двоичный вектор определённой длины. Она задаёт некоторые начальные значения для работы режимов и должна быть известна обеим сторонам для каждого шифруемого сообщения. При этом к ней предъявляются следующие требования:

Для режимов 4 и 5 синхропосылка должна выбираться случайным образом равновероятно из всех возможных двоичных векторов. 

Для режима 2 синхропосылка должна быть разной для всех сообщений, зашифрованных на одном и том же ключе.

Для режима 3 значение синхропосылки должно быть либо случайным либо уникальным.

Режим простой замены работает тривиально. Для зашифрования применяем блочный алгоритм к каждому блоку открытого текста, для расшифрования – к шифртексту.

Для режима гаммирования сначала вырабатывается гамма – битовый вектор, равный длине открытого текста. Вырабатывается он с помощью шифрования блочным шифром значений счётчика, причём начальное значение задаётся синхропосылкой. Потом гамма накладывается на открытый текст с помощью xor. Расшифрование, соответственно, точно так же.

Для гаммирования с обратной связью по выходу используется регистр сдвига. Изначально он заполняется синхропосылкой. Для выработки гаммы левая часть регистра зашифровывается блочным шифром, из чего получается гамма для очередного блока открытого текста. Потом содержимое регистра сдвигается на длину этой гаммы, а сама гамма записывается в регистр справа и процедура выработки повторяется для следующего блока. Гамма на блоки так же накладывается и “снимается” по xor.

Простая замена с зацеплением. Почти то же самое. Есть регистр сдвига длина больше, чем блок шифра. Сначала он заполняется синхропосылкой. Потом его старшая часть накладывается на открытый текст xor-ом, и результат зашифровывается. Регистр сдвигается влево на размер блока, а его младшая часть заполняется полученным зашифрованным блоком. Процедура повторяется.

То же самое, что и гаммирование с обратной связью по выходу, только в регистр справа дописывается не полученная на предыдущем шаге гамма, а результат её наложения на открытый текст, т.е. очередной блок шифртекста.

При выработке имитовставки в результате получается двоичный вектор фиксированной длины, в отличие от зашифрования. Для выработки имитовставки сначала из основного ключа генерируются два вспомогательных ключа, каждый по длине равен длине блока алгоритма шифрования. Для этого сначала на основном ключе зашифровывается нулевой вектор длиной как блок, потом с помощью сдвигов и xor с константой вырабатываются остальные. Дальше имитовставка вырабатывается просто: очередной блок зашифровывается блочным алгоритмом с основным ключом → результат зашифрования накладывается по xor на следующий блок открытого текста → полученный блок снова зашифровывается блочным алгоритмом с основным ключом. Исключением является последний блок. Для его вычисления берётся xor последнего блока открытого текста, предыдущего полученного блока имитовставки и один из вспомогательных ключей: первый, если блок полный, второй, если нет (блок дополняется). Результат этого xor также зашифровывается блочным алгоритмом на основном ключе.