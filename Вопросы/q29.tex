\section{Протоколы с разделением секрета.}

Разделение секрета -- ситуация, когда секрет (как правило, ключ) хранится по частям у нескольких сторон и только некоторое подмножество этих сторон может восстановить его. 

Это применяется для достижения двух целей: защиты от утери секрета и разделения ответственности за какие-либо важные действия с секретом (например, если ключ нужен для запуска какого-то оружия и т.п.).

Простейший вариант такой схемы -- когда секрет необходимо разделить между $n$ сторонами, и, только собравшись вместе, они должны иметь возможность его восстановить. Тогда можно применить следующий подход (предполагается, что секрет -- некоторый двоичный вектор или представим в таком виде): генерируется $n$ двоичных векторов так, чтобы они при сложении (побитовым xor) давали исходный секрет. Каждый из векторов раздаётся сторонам обмена. Таким образом, получается, что только сума всех векторов может дать результирующий секрет, тогда как любое их подмножество само по себе бесполезно.

Важно отметить, что в таком простом случае не подойдёт вариант просто разбить вектор на $n$ частей и отдать участникам, т.к. каждая из этих частей будет нести некоторую информацию об исходном секрете (тогда, например, собрав $n - 1$ частей, оставшуюся часть можно будет подобрать методом грубой силы), тогда как в предыдущем варианте каждый из векторов не раскрывает о секрете абсолютно ничего. 

Такая схема достаточно безопасна, но неудобна. На практике чаще возникают ситуации, когда нужно разделить секрет между $n$ участниками так, чтобы любые $m < n$ из них могли его восстановить. Алгоритм разделения ключа, удовлетворяющий описанному условию, называется $(m, n)$-пороговой схемой. 

Существует несколько реализаций таких схем, основанных на свойствах различных математических объектов. Здесь будет приведён один из наиболее простых подходов, предложенный Шамиром. 

Чтобы реализовать $(m, n)$-пороговую схему при таком подходе:

\begin{enumerate}
	\item Генерируется простое число $p$, большее $n$ и большее значения самого большого возможного секрета.
	\item Генерируется произвольный многочлен степени $m - 1$ вида 
	$$F(x) = a_{m - 1}x^{m - 1} + a_{m - 2}x^{m - 2} + ... + a_1x + M$$
	где $M$ -- разделяемый секрет. Коэффициенты $a_i$ хранятся в секрете и отбрасываются после распределения частей секрета.
	\item В качестве частей секрета вычисляются значения многочлена в различных точках, например, $k_1 = F(1)$, $k_2 = F(2)$ и т.д.
	\item Далее, чтобы восстановить $M$, необходимо решить систему из $m$ уравнений вида
	$$
	\begin{cases}
		\underbrace{a_{m - 1} \cdot 1^{m - 1} + a_{m - 2} \cdot 1^{m - 2} + ... + a_1 \cdot 1 + M}_{F(1)} = k_1, \\
		F(2) = k_2, \\
		..., \\
		F(i) = k_i, \\
		... \\
	\end{cases}
	$$
\end{enumerate}

Очевидно, что, если собрать меньше, чем $m$ частей, уравнение не решится. 

В этой схеме можно легко увеличить $n$, просто сгенерировав значения многочлена в новых точках.

Более того, как утверждает Шнайер, если $a_i$ выбраны случайно, то даже с бесконечными вычислительными мощностями злоумышленник никак не сможет получить секрет $M$, не собрав хотя бы $m$ его частей.   