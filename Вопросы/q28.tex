\section{Протоколы распределения ключей.}

Распределение ключей применяется в ситуации, когда у одной стороны есть ключ (полученный откуда-то, сгенерированный заранее, либо сгенерированный самостоятельно в начале работы протокола), и этот ключ необходимо <<раздать>> другим сторонам информационного обмена. 

Здесь различают три ситуации:

\begin{enumerate}
	\item С участием двух сторон при помощи симметричной криптографии
	\item С участием трёх сторон (два участника + доверенный центр) при помощи симметричной криптографии
	\item При помощи асимметричной криптографии
\end{enumerate}

Здесь и далее будут использоваться следующие обозначения:

\begin{itemize}
	\item $A$ и $B$ -- Алиса и Боб -- стороны информационного обмена; таким же образом будут обозначаться уникальные идентификаторы соответствующих сторон
	\item $T$ -- Трент -- ещё одна третья (доверенная) сторона информационного обмена, которой доверяют $A$ и $B$
	\item $K$ -- ключ шифрования
	\item $E_K(x)$ -- зашифрование сообщения $x$ на ключе шифрования $K$
	\item $D_K(x)$ -- расшифрование шифртекста $x$ на ключе шифрования $K$
	\item $t$ -- метка времени
	\item $r_X$ -- случайное число, сгенерированное стороной $X$
	\item $h_K(x)$ -- хеширование с применением ключа шифрования (выработка имитовставки)
	\item $\oplus$ -- побитовый xor
	\item $S_X(x)$ -- цифровая подпись сообщения $x$ закрытым ключом стороны $X$
\end{itemize}

\subsection{Две стороны и симметричная криптография}

В данном случае наиболее простой и наименее реалистичный вариант -- когда у двух сторон уже есть общий симметричный ключ, который они каким-то образом получили ранее, и им нужно распределить ещё один. 

Тогда можно воспользоваться таким одношаговым протоколом:

$A \rightarrow B: E_{K_{AB}}(K, t, B)$

Метка времени здесь необходима, чтобы злоумышленник, перехватив сообщение, не смог подменить этим сообщением аналогичное во время одного из следующих сеансов связи, т.к. в случае компрометации ключа $K$ он мог бы получить доступ к зашифрованным во время этого сеанса данных. Идентификатор принимающей стороны нужен, чтобы злоумышленник не смог использовать это сообщение для отправки обратно передающей стороне во время одного из следующих сеансов связи, когда эта сторона, возможно, уже будет принимающей.

Также есть вариация с использованием имитовставки вместо шифрования:

$A \rightarrow B: K \oplus h_{K_{AB}}(t, B)$

Вместо метки времени может использоваться случайное число, сгенерированное принимающей стороной.

А. Шамир (S из RSA) также предложил <<бесключевой>> протокол, позволяющий двум сторонам передать ключ, не имея какой либо общей секретной информации заранее. Для этого необходимо коммутирующее шифрующее преобразование $E: E_{K_1}(E_{K_2}(x)) = E_{K_2}(E_{K_1}(x))$, где $K_1$ и $K_2$ -- два разных ключа шифрования. 

Тогда Алиса может передать Бобу секретный ключ $K$ следующим образом:

\begin{enumerate}
	\item $A \rightarrow B: E_{K_A}(K)$
	\item $B \rightarrow A: E_{K_B}(E_{K_A}(K))$
	\item $A \rightarrow B: D_{K_A}(E_{K_B}(E_{K_A}(K))) = E_{K_B}(K)$
\end{enumerate}

\subsection{Три стороны стороны и симметричная криптография}

В трёхсторонних протоколах предполагается наличие некоторой третьей доверенной стороны $T$, у которой уже есть согласованные ключи с каждой из других сторон.

Один из первых протоколов состоит в следующем:

\begin{enumerate}
	\item $A \rightarrow T: A, B, r_A$
	\item $T \rightarrow A: E_{K_{AT}}(r_A, B, K, E_{K_{BT}}(K, A))$
	\item $A \rightarrow B: E_{K_{BT}}(K, A)$
	\item $B \rightarrow A: E_K(r_B)$
	\item $A \rightarrow B: E_K(r_B - 1)$
\end{enumerate}

Где $K_{XY}$ -- симметричный ключ сторон $X$ и $Y$. 

Проблема этого протокола состоит в том, что сообщение, переданное на шаге 3, злоумышленник может передать снова в одном из следующих сеансов связи, что станет проблемой, если переданный в этом сообщении ключ уже был скомпрометирован. 

Эта проблем решается в довольно известном протоколе Kerberos. Этот протокол использует две специальные криптографические сущности: <<билет>> и аутентификатор. 

Чтобы пообщаться с Бобом, Алиса должна получить у Трента <<билет>> на такое общение. Далее, чтобы начать общаться с Бобом, Алиса должна предъявить ему свой <<билет>> и аутентификатор. Аутентификатор Алиса может генерировать сама, <<билет>> может сгенерировать только Трент.

Билет выглядит следующим образом: $E_{K_{BT}}(K, A, L)$. Здесь: $K_{BT}$ -- ключ Боба и Трента, который они знают заранее, $L$ -- время действия билета, $K$ -- сеансовый ключ для общения Алисы с Бобом. Важно, что, несмотря на то, что билет выдаётся Алисе, расшифровать она его не может, т.к. он зашифрован ключом, который знают только Трент и Боб. Таким образом, она может только предъявить билет Бобу как есть, т.е. в зашифрованном виде. 

Аутентификатор выглядит так: $E_K(A, t, K_A)$, где $K_A$ -- секрет Алисы, который потом может быть использован для создания общего ключа. $K_A$ -- необязательный параметр, т.к. у Алисы и Боба к тому моменту уже есть сеансовый ключ, сгенерированный для них Трентом. 

Базовый протокол Kerberos содержит следующие шаги:

\begin{enumerate}
	\item $A \rightarrow T: A, B, r_A$
	\item $T \rightarrow A: E_{K_{AT}}(K, r_A, L, B), \underbrace{E_{K_{BT}}(K, A, L)}_\text{билет}$
	\item $A \rightarrow B: \underbrace{E_{K_{BT}}(K, A, L)}_\text{билет}, \underbrace{E_K(A, t, K_A)}_\text{аутентификатор}$
	\item $B \rightarrow A: E_K(t, K_B)$, где $K_B$ -- необязательный секрет Боба
\end{enumerate}

По окончании работы протокола Алиса и Боб могут сгенерировать новый общий секретный ключ из секретов $K_A$ и $K_B$.

Это был только базовый протокол. На практике используется два доверенных сервера. Один выдаёт билеты на получение билетов от второго, а второй уже выдаёт билеты на общение с нужным участником.

Есть ещё много протоколов, использующих симметричную криптографию и доверенную сторону: <<Лягушка с широким ртом>>, Yahalom, Needham-Schroeder, Otway-Rees, Neuman-Stubblebine.

\subsection{Две стороны стороны и асимметричная криптография}

Здесь в записях вида $E_X$ под $X$ всегда подразумевается открытый ключ, т.к. зашифрование возможно только с его помощью.

Наиболее простая вариация содержит всего один шаг:

$A \rightarrow B: E_{K_B}(K, t, A)$

Если нужна взаимная аутентификация, можно воспользоваться следующим протоколом:

\begin{enumerate}
	\item $A \rightarrow B: E_{K_B}(K_1, A)$
	\item $B \rightarrow A: E_{K_A}(K_1, K_2)$
	\item $A \rightarrow B: E_{K_B}(K_2)$
\end{enumerate}

Далее из секретов $K_1$ и $K_2$ может быть выработан общий секретный ключ. Пересылая эти секреты несколько раз, стороны убеждаются, что они верно расшифровали значение секрета, и что общаются они с нужным участником. 

Также для обмена ключами может использоваться цифровая подпись (что обычно и делается в современных протоколах). Например подпись может быть использована одним из следующих способов:

\begin{itemize}
	\item $A \rightarrow B: E_{K_B}(K, t, S_A(B, K, t))$
	\item $A \rightarrow B: E_{K_B}(K, t), S_A(B, K, t)$
	\item $A \rightarrow B: t, E_{K_B}(A, K), S_A(B, t, E_{K_B}(A, K)))$
\end{itemize}

Также, например, Шнайер приводит много протоколов, использующих подписи и доверенную сторону: DASS, Denning-Sacco, Woo-Lam.